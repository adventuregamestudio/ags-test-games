// Test Characters Module Script
int GetTestCharactersCount()
{
  return 8 + 8
  + 24 * 3 // turn on spot animating
  + 8 * 3  // idle start time
  ;
}

int game_ticks = 0;

void TestChangingDirectionLoop()
{
  Character* turner = cWalker2;
  turner.ChangeRoom(player.Room);
  turner.ChangeView(VWALKING2);
  
  turner.Loop = eDirectionDown;
  tap.is_int(turner.Loop, 0, "Character Loop is 0 (down)");
  turner.Loop = eDirectionLeft;
  tap.is_int(turner.Loop, 1, "Character Loop is 1 (left)");
  turner.Loop = eDirectionRight;
  tap.is_int(turner.Loop, 2, "Character Loop is 2 (right)");
  turner.Loop = eDirectionUp;
  tap.is_int(turner.Loop, 3, "Character Loop is 3 (up)");
  turner.Loop = eDirectionDownRight;
  tap.is_int(turner.Loop, 4, "Character Loop is 4 (down-right)");
  turner.Loop = eDirectionUpRight;
  tap.is_int(turner.Loop, 5, "Character Loop is 5 (up-right)");
  turner.Loop = eDirectionDownLeft;
  tap.is_int(turner.Loop, 6, "Character Loop is 6 (down-left)");
  turner.Loop = eDirectionUpLeft;
  tap.is_int(turner.Loop, 7, "Character Loop is 7 (up-left)");
}

void TestTurnOnSpotInstant()
{
  Character* turner = cWalker2;
  turner.ChangeRoom(player.Room);
  turner.ChangeView(VWALKING2);
  turner.Loop = eDirectionDown;
  SetGameOption(OPT_TURNWHENFACING, 0);
  
  turner.FaceDirection(eDirectionDown);
  tap.is_int(turner.Loop, 0, "Character facing down (instant)");
  turner.FaceDirection(eDirectionLeft);
  tap.is_int(turner.Loop, 1, "Character facing left (instant)");
  turner.FaceDirection(eDirectionRight);
  tap.is_int(turner.Loop, 2, "Character facing right (instant)");
  turner.FaceDirection(eDirectionUp);
  tap.is_int(turner.Loop, 3, "Character facing up (instant)");
  turner.FaceDirection(eDirectionDownRight);
  tap.is_int(turner.Loop, 4, "Character facing down-right (instant)");
  turner.FaceDirection(eDirectionUpRight);
  tap.is_int(turner.Loop, 5, "Character facing up-right (instant)");
  turner.FaceDirection(eDirectionDownLeft);
  tap.is_int(turner.Loop, 6, "Character facing down-left (instant)");
  turner.FaceDirection(eDirectionUpLeft);
  tap.is_int(turner.Loop, 7, "Character facing up-left (instant)");
}

void TestSingleTurn(Character *turner, String test_name, CharacterDirection from_dir, CharacterDirection next_dir,
  bool is_first_step)
{
  CharacterDirection cur_dir = turner.Loop;
  tap.is_int(cur_dir, from_dir, String.Format("Character turning (%s): starting loop", test_name));
  // NOTE: turning speed = character's walk animation speed
  int turn_speed;
  // NOTE: engine does not wait before the very first turn step
  if (is_first_step)
    turn_speed = 0;
  else
    turn_speed = turner.AnimationSpeed;
  //tap.Comment(String.Format("loop before = %d", turner.Loop));

  // Start with the wait, then increase a tick;
  // character switches to the next loop at the final tick
  int turn_tick = 0;
  int ticks_till_turn = 0;
  do
  {
    Wait(1);
    turn_tick++;
    
    if (turner.Loop == cur_dir)
    {
      ticks_till_turn++;
    }
  }
  while (cur_dir == turner.Loop);
  //tap.Comment(String.Format("loop after = %d", turner.Loop));
  tap.is_int(ticks_till_turn, turn_speed, String.Format("Character turning (%s): delay ticks", test_name));
  tap.is_int(turner.Loop, next_dir, String.Format("Character turning (%s): changed to next loop", test_name));
}

void TestTurnOnSpotAnimating()
{
  Character* turner = cWalker2;
  turner.ChangeRoom(player.Room);
  turner.ChangeView(VWALKING2);
  turner.DiagonalLoops = true;
  turner.TurnBeforeWalking = true;
  turner.AnimationSpeed = 5; // turning speed = anim speed
  turner.Loop = eDirectionDown;
  SetGameOption(OPT_TURNWHENFACING, 1);
  
  // Quarter-circle turns
  // Clockwise
  turner.FaceDirection(eDirectionLeft, eNoBlock);
  TestSingleTurn(turner, "down->left cw : down->downleft", eDirectionDown, eDirectionDownLeft, true);
  TestSingleTurn(turner, "down->left cw : downleft->left", eDirectionDownLeft, eDirectionLeft, false);
  turner.FaceDirection(eDirectionUp, eNoBlock);
  TestSingleTurn(turner, "left->up cw : left->upleft", eDirectionLeft, eDirectionUpLeft, true);
  TestSingleTurn(turner, "left->up cw : upleft->up", eDirectionUpLeft, eDirectionUp, false);
  turner.FaceDirection(eDirectionRight, eNoBlock);
  TestSingleTurn(turner, "up->right cw : up->upright", eDirectionUp, eDirectionUpRight, true);
  TestSingleTurn(turner, "up->right cw : upright->right", eDirectionUpRight, eDirectionRight, false);
  turner.FaceDirection(eDirectionDown, eNoBlock);
  TestSingleTurn(turner, "right->down cw : right->downright", eDirectionRight, eDirectionDownRight, true);
  TestSingleTurn(turner, "right->down cw : downright->down", eDirectionDownRight, eDirectionDown, false);
  // Counter-Clockwise
  turner.FaceDirection(eDirectionRight, eNoBlock);
  TestSingleTurn(turner, "down->right ccw : down->downright", eDirectionDown, eDirectionDownRight, true);
  TestSingleTurn(turner, "down->right ccw : downright->right", eDirectionDownRight, eDirectionRight, false);
  turner.FaceDirection(eDirectionUp, eNoBlock);
  TestSingleTurn(turner, "right->up ccw : right->upright", eDirectionRight, eDirectionUpRight, true);
  TestSingleTurn(turner, "right->up ccw : upright->up", eDirectionUpRight, eDirectionUp, false);
  turner.FaceDirection(eDirectionLeft, eNoBlock);
  TestSingleTurn(turner, "up->left ccw : up->upleft", eDirectionUp, eDirectionUpLeft, true);
  TestSingleTurn(turner, "up->left ccw : upleft->left", eDirectionUpLeft, eDirectionLeft, false);
  turner.FaceDirection(eDirectionDown, eNoBlock);
  TestSingleTurn(turner, "left->down ccw : left->downleft", eDirectionLeft, eDirectionDownLeft, true);
  TestSingleTurn(turner, "left->down ccw : downleft->down", eDirectionDownLeft, eDirectionDown, false);
  
  // Half-circle turns
  // Down->Up
  turner.Loop = eDirectionDown;
  turner.FaceDirection(eDirectionUp, eNoBlock);
  TestSingleTurn(turner, "down->up cw : down->downleft", eDirectionDown, eDirectionDownLeft, true);
  TestSingleTurn(turner, "down->up cw : downleft->left", eDirectionDownLeft, eDirectionLeft, false);
  TestSingleTurn(turner, "down->up cw : left->upleft", eDirectionLeft, eDirectionUpLeft, false);
  TestSingleTurn(turner, "down->up cw : upleft->up", eDirectionUpLeft, eDirectionUp, false);
  // Left->Right
  turner.Loop = eDirectionLeft;
  turner.FaceDirection(eDirectionRight, eNoBlock);
  TestSingleTurn(turner, "left->right cw : left->upleft", eDirectionLeft, eDirectionUpLeft, true);
  TestSingleTurn(turner, "left->right cw : upleft->up", eDirectionUpLeft, eDirectionUp, false);
  TestSingleTurn(turner, "left->right cw : up->upright", eDirectionUp, eDirectionUpRight, false);
  TestSingleTurn(turner, "left->right cw : upright->right", eDirectionUpRight, eDirectionRight, false);
}

import void TestIdleStartsInTime(Character* idler, int idle_start_delay, String test_name, int skip_ticks = 0, bool after_action = false);

void TestIdleStartsInTime(Character* idler, int idle_start_delay, String test_name, int skip_ticks, bool after_action)
{
  // Idle start timer is calculated in *seconds* rather than game ticks.
  int game_speed = GetGameSpeed();
  int idle_time = idle_start_delay * game_speed - skip_ticks;
  // NOTE: undocumented, but AGS does not decrement idle timer on each tick, 
  // instead it decrements whole second each game second, using seconds counted from
  // the *game's start*, rather than seconds counted from the last character action.
  int second_ticks_passed = game_ticks % game_speed;
  idle_time -= second_ticks_passed;
  //tap.Comment(String.Format("second_ticks_passed = %d", second_ticks_passed));
  
  // Also then it actually waits for 1 more second before starting idle view!
  // --- Except when NOT after action!
  if (!after_action)
  {
    idle_time += game_speed;
  }
  
  tap.isnt_int(idler.View, idler.IdleView, String.Format("Character idle start (%s): before idling", test_name));
  int delay_ticks = 0;
  int ticks_till_idle = 0;
  do
  {
    Wait(1);
    delay_ticks++;
    
    if (idler.View != idler.IdleView)
    {
      ticks_till_idle++;
    }
  }
  while (idler.View != idler.IdleView);
  //tap.Comment(String.Format("idle_time = %d, delay_ticks = %d, ticks_till_idle = %d", idle_time, delay_ticks, ticks_till_idle));
  tap.is_int(ticks_till_idle, idle_time - 1, String.Format("Character idle start (%s): delay ticks", test_name));
  tap.is_int(idler.View, idler.IdleView, String.Format("Character idle start (%s): started idling", test_name));
}

//
// Test that IdleView animation begins when certain time passes after the character action.
// NOTE: receive game speed as a parameter, because GetGameSpeed is unreliable with 1000+ values.
//
void TestIdleViewStart()
{
  Character* idler = cWalker1;
  idler.ChangeRoom(player.Room);
  int idle_start_delay = 1; // in seconds
  idler.SetIdleView(VIDLING, idle_start_delay);
  
  // NOTE: there's no property to return starting delay, so we pass that value as an argument
  TestIdleStartsInTime(idler, idle_start_delay, "initial");
  // Wait till current idle anim completes
  while (idler.View == idler.IdleView)
  {
    Wait(1);
  }
  TestIdleStartsInTime(idler, idle_start_delay, "after previous idle", 0, true);
    // note previous idling counts as action too, resetting idle timer by -1 s
  
  idler.Walk(idler.x - 10, idler.y, eBlock, eAnywhere);
  TestIdleStartsInTime(idler, idle_start_delay, "after walk", 0, true);
  
  SetGameOption(OPT_TURNWHENFACING, 0);
  idler.TurnBeforeWalking = false;
  idler.FaceDirection(eDirectionRight);
  TestIdleStartsInTime(idler, idle_start_delay, "after turn instant", 0, true);
  
  SetGameOption(OPT_TURNWHENFACING, 1);
  idler.TurnBeforeWalking = true;
  idler.FaceDirection(eDirectionLeft);
  TestIdleStartsInTime(idler, idle_start_delay, "after turn animated", 0, true);
  
  // Blocking say without speech view: idling is ticking and playing
  idle_start_delay = 2; // temporarily increase to 2 seconds, or the idling will begin right as speech is played
  idler.SetIdleView(VIDLING, idle_start_delay);
  Speech.SkipStyle = eSkipTime;
  idler.SpeechView = -1;
  int last_game_ticks = game_ticks;
  idler.Say("x");
  TestIdleStartsInTime(idler, idle_start_delay, "after blocking say no view", game_ticks - last_game_ticks, true);
    // note previous idling counts as action too, resetting idle timer by -1 s
  
  // Blocking say with speech view: idling is inactive
  idle_start_delay = 1; // in seconds
  idler.SetIdleView(VIDLING, idle_start_delay);
  idler.SpeechView = VSPEAKING;
  idler.Say("x");
  TestIdleStartsInTime(idler, idle_start_delay, "after blocking say has view", 0, true);
  
  idler.LockView(VANIMATE);
  idler.Animate(0, 0, eOnce, eBlock);
  idler.UnlockView();
  TestIdleStartsInTime(idler, idle_start_delay, "after custom animate", 0, true);
}

function repeatedly_execute_always()
{
  game_ticks++;
}

void TestCharacters()
{
  tap.Comment("start Character tests");
  int old_game_speed = GetGameSpeed();
  SetGameSpeed(1000);
  
  TestChangingDirectionLoop();
  TestTurnOnSpotInstant();
  TestTurnOnSpotAnimating();
  TestIdleViewStart();
  
  SetGameSpeed(old_game_speed);
  tap.Comment("end Character tests");
}
