// Test Characters Module Script
int GetTestCharactersCount()
{
  return 0
  + 1 // graphic pos
  + 8 // view frames
  + 8 + 8  // direction loops and instant turning
  + 24 * 3 // turn on spot animating
  + 8 * 3  // idle start time
  + 12 * 3 // direct move
  + 7 // waypoints move
  ;
}

//int test_render_num;
void _TestCharRenderF(Character *testChar, int sprite_num, eFlipDirection flip, const string test_name)
{
  Wait(1); // let engine redraw
  int sprite_w = Game.SpriteWidth[sprite_num];
  int sprite_h = Game.SpriteHeight[sprite_num];
  int sprite_x = testChar.x - sprite_w / 2;
  int sprite_y = testChar.y - sprite_h + 1;
  //tap.Comment(String.Format("sprite_x = %d, sprite_y = %d, sprite_w = %d, sprite_h = %d", sprite_x, sprite_y, sprite_w, sprite_h));
  //SaveScreenShot(String.Format("_%d.bmp", test_render_num));
  //test_render_num++;
  tap.ok(GfxComparer.TakeScreenshotAndMatchSprite(sprite_x, sprite_y, sprite_w, sprite_h, sprite_num, flip), test_name);
}

void _TestCharRender(Character *testChar, int sprite_num, const string test_name)
{
  _TestCharRenderF(testChar, sprite_num, eFlipNone, test_name);
}

void _TestCharViewFrame(Character *testChar, int view, int loop, int frame, const string test_name)
{
  testChar.LockViewFrame(view, loop, frame);
  ViewFrame* vf = Game.GetViewFrame(view, loop, frame);
  _TestCharRenderF(testChar, vf.Graphic, vf.Flipped, test_name);
  testChar.UnlockView();
}

#define SPRITE_DEFAULT 7

void TestGraphicPosition()
{
  cWalker1.LockViewFrame(VFLIP, 0, 0);
  _TestCharRender(cWalker1, SPRITE_DEFAULT, "Character: graphic position");
  cWalker1.UnlockView();
}

void TestViewRender()
{
  _TestCharViewFrame(cWalker1, VFLIP, 0, 0, "Character: view frame 0, normal");
  _TestCharViewFrame(cWalker1, VFLIP, 0, 1, "Character: view frame 1, normal");
  _TestCharViewFrame(cWalker1, VFLIP, 0, 2, "Character: view frame 2, h-flip");
  _TestCharViewFrame(cWalker1, VFLIP, 0, 3, "Character: view frame 3, h-flip");
  _TestCharViewFrame(cWalker1, VFLIP, 0, 4, "Character: view frame 4, v-flip");
  _TestCharViewFrame(cWalker1, VFLIP, 0, 5, "Character: view frame 5, v-flip");
  _TestCharViewFrame(cWalker1, VFLIP, 0, 6, "Character: view frame 6, hv-flip");
  _TestCharViewFrame(cWalker1, VFLIP, 0, 7, "Character: view frame 7, hv-flip");
}

void TestChangingDirectionLoop()
{
  Character* turner = cWalker2;
  turner.ChangeRoom(player.Room);
  turner.ChangeView(VWALKING2);
  
  turner.Loop = eDirectionDown;
  tap.is_int(turner.Loop, 0, "Character Loop is 0 (down)");
  turner.Loop = eDirectionLeft;
  tap.is_int(turner.Loop, 1, "Character Loop is 1 (left)");
  turner.Loop = eDirectionRight;
  tap.is_int(turner.Loop, 2, "Character Loop is 2 (right)");
  turner.Loop = eDirectionUp;
  tap.is_int(turner.Loop, 3, "Character Loop is 3 (up)");
  turner.Loop = eDirectionDownRight;
  tap.is_int(turner.Loop, 4, "Character Loop is 4 (down-right)");
  turner.Loop = eDirectionUpRight;
  tap.is_int(turner.Loop, 5, "Character Loop is 5 (up-right)");
  turner.Loop = eDirectionDownLeft;
  tap.is_int(turner.Loop, 6, "Character Loop is 6 (down-left)");
  turner.Loop = eDirectionUpLeft;
  tap.is_int(turner.Loop, 7, "Character Loop is 7 (up-left)");
}

void TestTurnOnSpotInstant()
{
  Character* turner = cWalker2;
  turner.ChangeRoom(player.Room);
  turner.ChangeView(VWALKING2);
  turner.Loop = eDirectionDown;
  SetGameOption(OPT_TURNWHENFACING, 0);
  
  turner.FaceDirection(eDirectionDown);
  tap.is_int(turner.Loop, 0, "Character facing down (instant)");
  turner.FaceDirection(eDirectionLeft);
  tap.is_int(turner.Loop, 1, "Character facing left (instant)");
  turner.FaceDirection(eDirectionRight);
  tap.is_int(turner.Loop, 2, "Character facing right (instant)");
  turner.FaceDirection(eDirectionUp);
  tap.is_int(turner.Loop, 3, "Character facing up (instant)");
  turner.FaceDirection(eDirectionDownRight);
  tap.is_int(turner.Loop, 4, "Character facing down-right (instant)");
  turner.FaceDirection(eDirectionUpRight);
  tap.is_int(turner.Loop, 5, "Character facing up-right (instant)");
  turner.FaceDirection(eDirectionDownLeft);
  tap.is_int(turner.Loop, 6, "Character facing down-left (instant)");
  turner.FaceDirection(eDirectionUpLeft);
  tap.is_int(turner.Loop, 7, "Character facing up-left (instant)");
}

void TestSingleTurn(Character *turner, String test_name, CharacterDirection from_dir, CharacterDirection next_dir,
  bool is_first_step)
{
  CharacterDirection cur_dir = turner.Loop;
  //tap.Comment(String.Format("loop before = %d", turner.Loop));
  tap.is_int(cur_dir, from_dir, String.Format("Character turning (%s): starting loop", test_name));
  // NOTE: turning speed = character's walk animation speed
  int turn_speed;
  // NOTE: engine does not wait before the very first turn step
  if (is_first_step)
    turn_speed = 0;
  else
    turn_speed = turner.AnimationSpeed;
  int turn_delay = turn_speed + 1; // if speed is 0, there will be still 1 tick to update the turn

  // Start with the wait, then increase a tick;
  // character switches to the next loop at the final tick
  int ticks_till_turn = 0;
  while (cur_dir == turner.Loop)
  {
    Wait(1);
    ticks_till_turn++;
  }
  //tap.Comment(String.Format("loop after = %d", turner.Loop));
  tap.is_int(ticks_till_turn, turn_delay, String.Format("Character turning (%s): delay ticks", test_name));
  tap.is_int(turner.Loop, next_dir, String.Format("Character turning (%s): changed to next loop", test_name));
}

void TestTurnOnSpotAnimating()
{
  Character* turner = cWalker2;
  turner.ChangeRoom(player.Room);
  turner.ChangeView(VWALKING2);
  turner.DiagonalLoops = true;
  turner.TurnBeforeWalking = true;
  turner.AnimationSpeed = 5; // turning speed = anim speed
  turner.Loop = eDirectionDown;
  SetGameOption(OPT_TURNWHENFACING, 1);
  
  // Quarter-circle turns
  // Clockwise
  turner.FaceDirection(eDirectionLeft, eNoBlock);
  TestSingleTurn(turner, "down->left cw : down->downleft", eDirectionDown, eDirectionDownLeft, true);
  TestSingleTurn(turner, "down->left cw : downleft->left", eDirectionDownLeft, eDirectionLeft, false);
  turner.FaceDirection(eDirectionUp, eNoBlock);
  TestSingleTurn(turner, "left->up cw : left->upleft", eDirectionLeft, eDirectionUpLeft, true);
  TestSingleTurn(turner, "left->up cw : upleft->up", eDirectionUpLeft, eDirectionUp, false);
  turner.FaceDirection(eDirectionRight, eNoBlock);
  TestSingleTurn(turner, "up->right cw : up->upright", eDirectionUp, eDirectionUpRight, true);
  TestSingleTurn(turner, "up->right cw : upright->right", eDirectionUpRight, eDirectionRight, false);
  turner.FaceDirection(eDirectionDown, eNoBlock);
  TestSingleTurn(turner, "right->down cw : right->downright", eDirectionRight, eDirectionDownRight, true);
  TestSingleTurn(turner, "right->down cw : downright->down", eDirectionDownRight, eDirectionDown, false);
  // Counter-Clockwise
  turner.FaceDirection(eDirectionRight, eNoBlock);
  TestSingleTurn(turner, "down->right ccw : down->downright", eDirectionDown, eDirectionDownRight, true);
  TestSingleTurn(turner, "down->right ccw : downright->right", eDirectionDownRight, eDirectionRight, false);
  turner.FaceDirection(eDirectionUp, eNoBlock);
  TestSingleTurn(turner, "right->up ccw : right->upright", eDirectionRight, eDirectionUpRight, true);
  TestSingleTurn(turner, "right->up ccw : upright->up", eDirectionUpRight, eDirectionUp, false);
  turner.FaceDirection(eDirectionLeft, eNoBlock);
  TestSingleTurn(turner, "up->left ccw : up->upleft", eDirectionUp, eDirectionUpLeft, true);
  TestSingleTurn(turner, "up->left ccw : upleft->left", eDirectionUpLeft, eDirectionLeft, false);
  turner.FaceDirection(eDirectionDown, eNoBlock);
  TestSingleTurn(turner, "left->down ccw : left->downleft", eDirectionLeft, eDirectionDownLeft, true);
  TestSingleTurn(turner, "left->down ccw : downleft->down", eDirectionDownLeft, eDirectionDown, false);
  
  // Half-circle turns
  // Down->Up
  turner.Loop = eDirectionDown;
  turner.FaceDirection(eDirectionUp, eNoBlock);
  TestSingleTurn(turner, "down->up cw : down->downleft", eDirectionDown, eDirectionDownLeft, true);
  TestSingleTurn(turner, "down->up cw : downleft->left", eDirectionDownLeft, eDirectionLeft, false);
  TestSingleTurn(turner, "down->up cw : left->upleft", eDirectionLeft, eDirectionUpLeft, false);
  TestSingleTurn(turner, "down->up cw : upleft->up", eDirectionUpLeft, eDirectionUp, false);
  // Left->Right
  turner.Loop = eDirectionLeft;
  turner.FaceDirection(eDirectionRight, eNoBlock);
  TestSingleTurn(turner, "left->right cw : left->upleft", eDirectionLeft, eDirectionUpLeft, true);
  TestSingleTurn(turner, "left->right cw : upleft->up", eDirectionUpLeft, eDirectionUp, false);
  TestSingleTurn(turner, "left->right cw : up->upright", eDirectionUp, eDirectionUpRight, false);
  TestSingleTurn(turner, "left->right cw : upright->right", eDirectionUpRight, eDirectionRight, false);
}

import void TestIdleStartsInTime(Character* idler, int idle_start_delay, String test_name, int skip_ticks = 0, bool after_action = false);

void TestIdleStartsInTime(Character* idler, int idle_start_delay, String test_name, int skip_ticks, bool after_action)
{
  // Idle start timer is calculated in *seconds* rather than game ticks.
  int game_speed = Game.Speed;
  int idle_time = idle_start_delay * game_speed - skip_ticks;
  // NOTE: undocumented, but AGS does not decrement idle timer on each tick, 
  // instead it decrements whole second each game second, using seconds counted from
  // the *game's start*, rather than seconds counted from the last character action.
  int second_ticks_passed = GT.GameTicks % game_speed;
  idle_time -= second_ticks_passed;
  //tap.Comment(String.Format("second_ticks_passed = %d", second_ticks_passed));
  
  // Also then it actually waits for 1 more second before starting idle view!
  // --- Except when NOT after action!
  if (!after_action)
  {
    idle_time += game_speed;
  }
  idle_time = idle_time + 1; // if speed is 0, there will be still 1 tick to update the idle timer
  
  tap.isnt_int(idler.View, idler.IdleView, String.Format("Character idle start (%s): before idling", test_name));
  int ticks_till_idle = 0;
  while (idler.View != idler.IdleView)
  {
    Wait(1);
    ticks_till_idle++;
  }
  //tap.Comment(String.Format("idle_time = %d, ticks_till_idle = %d", idle_time, ticks_till_idle));
  tap.is_int(ticks_till_idle, idle_time, String.Format("Character idle start (%s): delay ticks", test_name));
  tap.is_int(idler.View, idler.IdleView, String.Format("Character idle start (%s): started idling", test_name));
}

//
// Test that IdleView animation begins when certain time passes after the character action.
// NOTE: receive game speed as a parameter, because GetGameSpeed is unreliable with 1000+ values.
//
void TestIdleViewStart()
{
  Character* idler = cWalker1;
  idler.ChangeRoom(player.Room);
  int idle_start_delay = 1; // in seconds
  idler.SetIdleView(VIDLING, idle_start_delay);
  
  // NOTE: there's no property to return starting delay, so we pass that value as an argument
  TestIdleStartsInTime(idler, idle_start_delay, "initial");
  // Wait till current idle anim completes
  while (idler.View == idler.IdleView)
  {
    Wait(1);
  }
  TestIdleStartsInTime(idler, idle_start_delay, "after previous idle", 0, true);
    // note previous idling counts as action too, resetting idle timer by -1 s
  
  idler.Walk(idler.x - 10, idler.y, eBlock, eAnywhere);
  TestIdleStartsInTime(idler, idle_start_delay, "after walk", 0, true);
  
  SetGameOption(OPT_TURNWHENFACING, 0);
  idler.TurnBeforeWalking = false;
  idler.FaceDirection(eDirectionRight);
  TestIdleStartsInTime(idler, idle_start_delay, "after turn instant", 0, true);
  
  SetGameOption(OPT_TURNWHENFACING, 1);
  idler.TurnBeforeWalking = true;
  idler.FaceDirection(eDirectionLeft);
  TestIdleStartsInTime(idler, idle_start_delay, "after turn animated", 0, true);
  
  // Blocking say without speech view: idling is ticking and playing
  idle_start_delay = 2; // temporarily increase to 2 seconds, or the idling will begin right as speech is played
  idler.SetIdleView(VIDLING, idle_start_delay);
  Speech.SkipStyle = eSkipTime;
  idler.SpeechView = -1;
  int last_game_ticks = GT.GameTicks;
  idler.Say("x");
  TestIdleStartsInTime(idler, idle_start_delay, "after blocking say no view", GT.GameTicks - last_game_ticks, true);
    // note previous idling counts as action too, resetting idle timer by -1 s
  
  // Blocking say with speech view: idling is inactive
  idle_start_delay = 1; // in seconds
  idler.SetIdleView(VIDLING, idle_start_delay);
  idler.SpeechView = VSPEAKING;
  idler.Say("x");
  TestIdleStartsInTime(idler, idle_start_delay, "after blocking say has view", 0, true);
  
  idler.LockView(VANIMATE);
  idler.Animate(0, 0, eOnce, eBlock);
  idler.UnlockView();
  TestIdleStartsInTime(idler, idle_start_delay, "after custom animate", 0, true);
}

void TestMoveDirect(Character* walker, String test_name, int sx, int sy, int dx, int dy, bool use_walk, BlockingStyle style)
{
  walker.x = sx;
  walker.y = sy;
  if (use_walk)
  {
    walker.Walk(dx, dy, style, eAnywhere);
  }
  else
  {
    walker.Move(dx, dy, style, eAnywhere);
  }
  if (style == eNoBlock)
  {
    while (walker.Moving) Wait(1);
  }
  tap.ok(!walker.Moving, String.Format("%s: finished move", test_name));
  tap.is_int(walker.x, dx, String.Format("%s: destination x", test_name));
  tap.is_int(walker.y, dy, String.Format("%s: destination y", test_name));
}

void TestMoveDirectToWaypoint(Character* walker, String test_name, int p_start, int p_end, int t_const, bool x_axis)
{
  int p_range1, p_range2;
  if (p_start <= p_end)
  {
    p_range1 = p_start;
    p_range2 = p_end;
  }
  else
  {
    p_range1 = p_end;
    p_range2 = p_start;
  }
  
  bool p_coords_in_range = true;
  bool t_coords_const = true;
  while (walker.Moving && (x_axis && walker.x != p_end) || (!x_axis && walker.y != p_end))
  {
    if (x_axis)
    {
      if (!(walker.x >= p_range1 && walker.x <= p_range2))
      {
        p_coords_in_range = false;
      }
      if (walker.x != p_end && walker.y != t_const)
      {
        t_coords_const = false;
      }
    }
    else
    {
      if (!(walker.y >= p_range1 && walker.y <= p_range2))
      {
        p_coords_in_range = false;
      }
      if (walker.y != p_end && walker.x != t_const)
      {
        t_coords_const = false;
      }
    }
    
    Wait(1);
  }
  tap.ok(p_coords_in_range && t_coords_const, String.Format("%s: move position stayed in range", test_name));
  // NOTE: we cannot test exact coords here, because character may already be turned and start moving towards next waypoint
}

// Tests moving and walking WITHOUT pathfinding (eAnywhere), 
// only for the sake of testing the fact of movement itself.
void TestSimpleMovement(Character* walker)
{
  // Move
  TestMoveDirect(walker, "Character.Move eBlock Hor", 0, 0, 100, 0, false, eBlock);
  TestMoveDirect(walker, "Character.Move eBlock Ver", 0, 0, 0, 100, false, eBlock);
  TestMoveDirect(walker, "Character.Move eBlock Diag", 0, 0, 100, 100, false, eBlock);
  TestMoveDirect(walker, "Character.Move eNoBlock Hor", 0, 0, 100, 0, false, eNoBlock);
  TestMoveDirect(walker, "Character.Move eNoBlock Ver", 0, 0, 0, 100, false, eNoBlock);
  TestMoveDirect(walker, "Character.Move eNoBlock Diag", 0, 0, 100, 100, false, eNoBlock);
  // Walk
  TestMoveDirect(walker, "Character.Walk eBlock Hor", 0, 0, 100, 0, true, eBlock);
  TestMoveDirect(walker, "Character.Walk eBlock Ver", 0, 0, 0, 100, true, eBlock);
  TestMoveDirect(walker, "Character.Walk eBlock Diag", 0, 0, 100, 100, true, eBlock);
  TestMoveDirect(walker, "Character.Walk eNoBlock Hor", 0, 0, 100, 0, true, eNoBlock);
  TestMoveDirect(walker, "Character.Walk eNoBlock Ver", 0, 0, 0, 100, true, eNoBlock);
  TestMoveDirect(walker, "Character.Walk eNoBlock Diag", 0, 0, 100, 100, true, eNoBlock);
  
  // AddWaypoint
  walker.x = 0;
  walker.y = 0;
  walker.AddWaypoint(100, 0);
  walker.AddWaypoint(100, 100);
  walker.AddWaypoint(0, 100);
  walker.AddWaypoint(0, 0);
  TestMoveDirectToWaypoint(walker, "Character.AddWaypoint 0,0->1,0", 0, 100, 0, true);
  TestMoveDirectToWaypoint(walker, "Character.AddWaypoint 1,0->1,1", 0, 100, 100, false);
  TestMoveDirectToWaypoint(walker, "Character.AddWaypoint 1,1->0,1", 100, 0, 100, true);
  TestMoveDirectToWaypoint(walker, "Character.AddWaypoint 0,1->0,0", 100, 0, 0, false);
  tap.ok(!walker.Moving, String.Format("%s: finished move", "Character.AddWaypoint"));
  tap.is_int(walker.x, 0, String.Format("%s: destination x", "Character.AddWaypoint"));
  tap.is_int(walker.y, 0, String.Format("%s: destination y", "Character.AddWaypoint"));
}

void TestCharacters()
{
  tap.Comment("start Character tests");
  int old_game_speed = Game.Speed;
  Game.Speed = 1000;
  
  // Disable characters and objects, avoid interfering with our tests
  for (int i = 0; i < Game.CharacterCount; i++)
    character[i].Visible = false;
  for (int i = 0; i < Room.ObjectCount; i++)
    object[i].Visible = false;
  
  Game.Camera.SetAt(0, 0);
  cWalker1.ChangeRoom(player.Room);
  cWalker1.x = 100;
  cWalker1.y = 100;
  cWalker1.Enabled = true;
  cWalker1.Visible = true;
  cWalker1.Transparency = 0;
  cWalker1.ManualScaling = true;
  cWalker1.Scaling = 100;
  
  TestGraphicPosition();
  TestViewRender();
  
  cWalker1.Enabled = true;
  cWalker2.Enabled = true;
  
  TestChangingDirectionLoop();
  TestTurnOnSpotInstant();
  TestTurnOnSpotAnimating();
  TestIdleViewStart();
  TestSimpleMovement(cWalker1);
  
  Game.Speed = old_game_speed;
  tap.Comment("end Character tests");
}
